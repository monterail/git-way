#!/usr/bin/env sh
BASEDIR=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)")
VERSION=$(cat $BASEDIR/VERSION)

usage() {
  read -d '' usage <<- EOF
Version: $VERSION

usage: git <command> <subcommand> [<identifier>]

<identifier> will try to match one of existing feature or fix branches. It is
assumed that they are prefixed with 'feature/' and 'fix/' respectively, but the
prefix must not be included in the <identifier>, it is inferred from <command>.

Numeric <identifier> matches in the following way: '40' will match feature/40-foo
but not feature/404.

Non-numeric <identifier> matches any portion of the branch name. E.g. 'foo' will
match feature/foo, feature/foobar and feature/40-foo.

If the current branch is a feature or fix branch you can omit the <identifier>.


Commands:
  feature     Makes subcommands work on feature branches.

  fix         Makes subcommands work on fix branches.


Subcommands:
  open        Switches to branch specified by <identifier>. It will be created
              if needed and automatically track respective remote branch if it
              exists.

  release     Merges branch specified by <identifier> into master branch and pushes
              to remote. Both local branch and its tracked remote branch will be
              deleted afterwards.

  stage       Merges branch specified by <identifier> into staging branch and
              pushes to remote.

  sync        Synchronizes local branch with its tracked remote branch, i.e.
              rebases local branch onto remote and pushes changes to remote.

EOF

  echo "$usage"
}

cmd() {
  echo "\033[33;32m$ $1\033[0m"
  eval $1
}

match_branch() {
  local branch
  local patterns

  if [ -z $2 ]; then
    branch=$(git rev-parse --abbrev-ref HEAD)
    case $branch in
      $1/*)
        # current branch is a feature branch
        ;;
      *)
        # current branch is not a feature branch, reset branch name
        branch=''
        ;;
    esac
  else
    case $2 in
      *[!0-9]*)
        # not a number, so we can have partial match, e.g. "foo" should match feature/foobar
        patterns=(*$1/*$2*)
        ;;
      *)
        # number, so we need a perfect prefix match, e.g. "40" should match feature/40-foo, but not feature/40foo or feature/400
        patterns=(*$1/$2 *$1/$2-*)
        ;;
    esac

    for pattern in ${patterns[@]}; do
      branch=$(git branch --all --list $pattern | head -n 1 | sed -e "s:remotes/origin/::" | tr -d '* ')
      [ ! -z $branch ] && break
    done

    [ -z $branch ] && branch="$1/$2"
  fi

  echo $branch;
}

local_branch_exists() {
  git show-ref --verify --quiet refs/heads/$1
}

remote_branch_exists() {
  git show-ref --verify --quiet refs/remotes/origin/$1
}

checkout() {
  if local_branch_exists $1; then
    cmd "git checkout $1"
  elif remote_branch_exists $1; then
    cmd "git checkout -b $1 origin/$1"
  else
    cmd "git checkout -b $1 master"
  fi
}

fetch() {
  cmd "git fetch --prune"
}

sync() {
  checkout $1
  if remote_branch_exists $1; then
    cmd "git pull --rebase"
  fi
  push $1
}

merge() {
  cmd "git merge --no-edit --no-ff $1"
}

rebase() {
  cmd "git rebase master"
}

push() {
  local remote=$(git config --get branch.$1.remote)
  local branch=$(git config --get branch.$1.merge | sed -e "s:refs/heads/::")

  [ -z $remote ] && remote=origin
  [ -z $branch ] && branch=$1

  [ $branch != $1 ] && branch="$1:$branch"

  cmd "git push --set-upstream $remote $branch"
}

delete() {
  if remote_branch_exists $1; then
    local remote=$(git config --get branch.$1.remote)
    local branch=$(git config --get branch.$1.merge | sed -e "s:refs/heads/::")

    cmd "git push $remote :$branch"
  fi

  cmd "git branch -D $1"
}

require_feature_branch() {
  [ -z $BRANCH ] && usage && exit
}

# Subcommands

subcmd_open() {
  require_feature_branch
  checkout $1
}

subcmd_sync() {
  require_feature_branch
  fetch && \
  sync $1
}

subcmd_stage() {
  require_feature_branch
  fetch && \
  sync $1 && \
  push $1 && \
  sync staging && \
  merge $1 && \
  push staging
  checkout master
}

subcmd_release() {
  require_feature_branch
  fetch && \
  sync master && \
  sync $1 && \
  rebase $1 && \
  checkout master && \
  merge $1 && \
  push master && \
  delete $1
}

# Run

COMMAND=$1
SUBCOMMAND=$2
IDENTIFIER=$3
BRANCH=$(match_branch $COMMAND $IDENTIFIER)

case $SUBCOMMAND in
  open)
    subcmd_open $BRANCH
    ;;
  stage)
    subcmd_stage $BRANCH
    ;;
  release)
    subcmd_release $BRANCH
    ;;
  sync)
    subcmd_sync $BRANCH
    ;;
  *)
    usage
    ;;
esac

